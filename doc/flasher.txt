netX flasher
============
Doc Bacardi <doc_bacardi@sourceforge.net>
:Author Initials: DB


== About

The flasher is a program for the netX network controllers from Hilscher (http://www.hilscher.com).
It's main use case is writing a bootable image to an SPI or parallel flash.

In general the flasher works with flash devices. It can...

 * Read data from the device
 * Write data from the device
 * Erase the complete device or parts of it
 * Build a checksum over the device contents

Some common use cases are:

 * Write a Hilscher 2ndStage loader to the SPI flash.
 * Write a custom firmware.
 * Add a serial number to a pre-burned flash image.

The flasher is a stand-alone application. It does not require an OS like rcX or WindowsCE.

The recommended way to use the flasher is a LUA script on a standard PC. The chapter XYZ has more details on this topic.

It is also possible to run the flasher without LUA. This is described in the chapter XYZ.

If you would like to modify the flasher, it is necessary to build it from the sources. The chapter <<Building_the_flasher_from_source>> gives more details on the build process.
The most common modification is the addition of new SPI flash types. Please see chapter XYZ for more details about this task.


[[Building_the_flasher_from_source, Building the flasher from source]]
== Building the flasher from source

Building the netX flasher is currently supported on Linux operating systems and some versions of Windows. Please note that the following versions of Windows are not supported:

 * Windows Vista
 * Windows 7
 * Windows Server 2008

To compile the netX flasher you need only 1 tool: Python. A small python script will take care of the rest of the dependencies.

Recommended versions:

 * Python >= 2.6

[IMPORTANT]
Please note that Python3 is not yet supported. At the time of writing most tools used in the build process are not ready for Python3.


=== Setting up the build system on Linux

Most distributions have python preinstalled. Try to execute the command `python --version` in a shell. This will print the python version if it is installed.

-----------------------------------------------------------------------------
 hindin:/home/brynhild$ python --version
 Python 2.6.6
-----------------------------------------------------------------------------

If no python is installed, search the list of available software packets for the term 'python'.

.Example for debian based systems
-----------------------------------------------------------------------------
 apt-get install python
-----------------------------------------------------------------------------

If you prefer to install python by hand:

 1. Python 2.x.x: http://www.python.org/download . The source package has build instructions.


=== Setting up the build system on Windows

Download and install the packages from the following locations:

 1. Python 2.x.x: http://www.python.org/download . The installer presents several features to be installed. You can save disk space and select only "Register Extensions". You do not need "Tcl/Tk", "Documentation", "Utility Scripts" and the "Test Suite".


=== Compile

Open a command line window and change to the folder where you unpacked the flasher sources. There is a file named 'setup.xml'. Run the command 'python mbs/mbs' there. After some time and a lot of output, the target folder contains the binaries and this documentation.

.Example output of the build process on linux
-----------------------------------------------------------------------------
 hindin:/home/brynhild/flasher$ python mbs/mbs
 Processing package scons-local, version 2.3.0_1
 The package is not in the repository. It must be downloaded.
 Trying repository at http://downloads.sourceforge.net/project/muhkuh/mbs/...
 sizTotal 41
   0% 
 sizTotal 318035
   0% ..................................................
  32% ..................................................
  64% ..................................................
  96% .....
 The checksums match: OK!
 Unpacking...
 Installed package.
 Processing package asciidoc, version 8.6.8_1
[...]
-----------------------------------------------------------------------------


.List of produced files
 * `targets/flasher_netx10.bin` : the netX10 version
 * `targets/flasher_netx10_debug.bin` : the netX10 version with a lot of debug output
 * `targets/flasher_netx500.bin` : the netX500 version
 * `targets/flasher_netx500_bob.bin` : the netX500 version for the BOB project
 * `targets/flasher_netx500_debug.bin` : the netX500 version with a lot of debug output
 * `targets/flasher_netx50.bin` : the netX50 version
 * `targets/flasher_netx50_debug.bin` : the netX50 version with a lot of debug output
 * `targets/flasher_netx56.bin` : the netX51/52 version
 * `targets/flasher_netx56_debug.bin` : the netX51/52 version with a lot of debug output
 * `targets/lua/flasher.lua` : LUA support routines for the Muhkuh testing environment
 * `targets/doc/flasher.html` : this documentation
 * `targets/doc/README.rst` : a short introduction of the flasher for the Sourceforge download page
 * `targets/doc/spi_flash_list.txt` : a list of all supported SPI flashes which do not support the SFDP autodetection (this list contains only the names)
 * `targets/doc/spi_flash_types.html` : a list of all supported SPI flashes which do not support the SFDP autodetection (this list contains a lot of details)


== Using the flasher

The flasher itself is a program for


=== Using the flasher with LUA.

[source,lua]
-----------------------------------------------------------------------------
require("flasher")


if #arg~=1 then
	error("Missing parameter: file to flash.")
end
strFileName = arg[1]


tPlugin = tester.getCommonPlugin()
if not tPlugin then
	error("No plugin selected, nothing to do!")
end


-- Flash the file.
local tBus = flasher.BUS_Spi
local ulUnit = 0
local ulChipSelect = 0
flasher.simple_flasher(tPlugin, strFileName, tBus, ulUnit, ulChipSelect, "netx/")

print("")
print(" #######  ##    ## ")
print("##     ## ##   ##  ")
print("##     ## ##  ##   ")
print("##     ## #####    ")
print("##     ## ##  ##   ")
print("##     ## ##   ##  ")
print(" #######  ##    ## ")
print("")

-- Disconnect the plugin.
tester.closeCommonPlugin()
-----------------------------------------------------------------------------

 
=== Using the flasher as a standalone application:

 1. Download the flasher to the netx with the a jtag debugger or the netxusbmon tool. The load address is 0x8000.

 1. Write the parameters for your flash operation to a free place in the IntRam (like 0x00017000). They include:
   * device to flash the data to (Spi flash, parallel flash, etc...)
   * size of the data to flash (in bytes)
   * offset in this device (in bytes)

   Below is an example for the parameters.

 1. Download your data to a free ram area in the netX, preferably the SDRam. Please don't forget to set up the SDRam controller first.

 1. Execute the flasher and pass the address of the parameters in the register R0. The result of the flash operation is written to the parameter field (see below), progress output is on Uart0 with 115.2k, 8N1. The execution address is 0x8000 (same as the load address).


=== Parameter details

All parameters are 32 bit values (dwords). The first part of the parameter block is a general header, the second part contain the flash specific settings:

.Header
[cols="<,<",frame="topbot",options="header"]
|==========================
|Offset/Bytes | Meaning
|      `0x00` | Return value, `0` means success, failure otherwise (should be cleared with `0xffffffff` before start)
|      `0x04` | Address of the flash specific parameters.
|      `0x08` | Reserved (init with `0x00000000`)
|==========================


.Flash specific settings
[cols="<,<",frame="topbot",options="header"]
|==========================
|Offset/Bytes | Meaning
|      `0x00` | parameter version
|      `0x04` | operation mode
|      `0x08` | start address of the data
|      `0x0c` | size (in bytes) of the data
|      `0x10` | device typ
|      `0x14` | device offset (in bytes)
|==========================

=== Parameter Version

The current version of the parameter block is 1.0 . The version number before the dot is the major, the part behind
the dot is the minor, so 1.0 has a major of 1 and a minor of 0. The version number is encoded in a dword as

 'major' * 65536 + 'minor'

or in C syntax: ('major'<<16)|'minor'

Example: The version number 1.2 is encoded as `0x00010002`.


=== Device Typ:

[cols="<,<",frame="topbot",options="header"]
|==========================
|  Id | Meaning
| `0` | reserved, do not use
| `1` | parallel flash on sram bus, chip select 0
| `2` | SPI flash, chip select 0
| `3` | I2C eeprom
| `4` | reserved, do not use
| `5` | reserved, do not use
| `6` | reserved, do not use
| `7` | reserved, do not use
|==========================


=== Operation Mode

The operation mode selects the action which is executed by the flasher tool:

 OperationMode_Flash  = 0     flash data to the device
 OperationMode_Erase  = 1     erase a region of (or the complete) the device
 OperationMode_Read   = 2     read the contents of the device
 OperationMode_Verify = 3     compare the device contents with provided data

.Example Lauterbach script.
-----------------------------------------------------------------------------
 // clear return value
 data.set 0x00017000 %LONG 0xffffffff
 // set input parameter address of flasher parameter block)
 data.set 0x00017004 %LONG 0x0001700c
 // clear return message
 data.set 0x00017008 %LONG 0x00000000

 // param version
 data.set 0x0001700C %LONG 0x00010000
 // operation mode is flash
 data.set 0x00017010 %LONG 0
 // data pointer
 data.set 0x00017014 %LONG 0x80000000
 // data byte size
 data.set 0x00017018 %LONG &binfile_size
 // source type is SPI
 data.set 0x0001701C %LONG &BootBlockSrcType_SPI
 // dst dev offset
 data.set 0x00017020 %LONG 0
-----------------------------------------------------------------------------


=== Example for the parameters
A data block of 0x3000 bytes should be flashed to the beginning of the SPI flash. The data is downloaded to the start of the SDRam. The parameter header is written to 0x00017000, the flash specific settings are placed right behind the header (0x0001700c).

[cols=">m,>m,<",frame="topbot",options="header"]
|============================================================================
|    Address |      Value | Meaning
| 0x00017000 | 0xffffffff | clear return value
| 0x00017004 | 0x0001700c | address of the flash specific parameters
| 0x00017008 | 0x00000000 | clear return message
|            |            |
| 0x0001700c | 0x00010000 | parameter version is 1.0
| 0x00017010 | 0x00000000 | set operation mode to "flash data"
| 0x00017014 | 0x80000000 | pointer to the start of the data
| 0x00017018 | 0x00003000 | size of the data in bytes
| 0x0001701c | 0x00000002 | device typ is SPI flash
| 0x00017020 | 0x00000000 | start offset in the SPI flash
|============================================================================

After both the flasher and your data is downloaded to the netX memory and the parameters are set, load the address of the parameter block (in this example `0x00017000`) into the CPU register `R0` and execute the flasher at address `0x8000`. When the call returns, the first entry of the parameters (the return value) contains the result of the operation. A `0` means success, other values indicate a failure. For detailed messages, connect Uart0 of the netX with a "Nullmodem Cable" to your PC and configure your COM port to 115.2K, 8 databits, no parity and 1 Stopbit (8N1).
The output of a successful flash operation looks like this:

.Example flasher output.
-----------------------------------------------------------------------------
  . *** Flasher start ***
  . Data pointer:    0x00017000
  . Init parameter:  0x0001700C

  . Application parameters:
  . data start:    0x80000000
  . data size:     0x00006020
  . boot type:     0x00000002
  . device offset: 0x00000000

  . Boot type :SPI flash
  . Detecting SPI flash...
  . ok, found AT45DB321B
  . Check size...
  . data size:  0x00006020
  . flash size: 0x00420000
  . ok, data fits into flash
  . Erase flash...
  . erase done
  . Write data...
  % 00000000/0000002F
  % 00000026/0000002F
  % 0000002F/0000002F
  . write done
  . Verify data...
  % 00000000/00000061
  % 00000061/00000061
  . verify ok
  * OK *
-----------------------------------------------------------------------------

